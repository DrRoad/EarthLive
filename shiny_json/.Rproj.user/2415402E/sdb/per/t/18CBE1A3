{
    "collab_server" : "",
    "contents" : "PrepareTwitter<-function()\n{\n  library(shiny)\n  library(twitteR)\n  library(RCurl)\n  library(RJSONIO)\n  library(stringr)\n  library(tm)\n  library(wordcloud)\n#   library(httr)\n#   library(ROAuth)\n#   library(plotrix)\n#   library(ROAuth)\n#   library(plyr)\n#   library(dplyr)\n#   library(ggplot2)\n  \n  library(twitteR)\n  library(RCurl)\n  library(RJSONIO)\n  library(stringr)\n  library(tm)\n  library(wordcloud)\n}\nPrepareTwitter()\n\n#load(\"credential\") # A credential obtained from twitter permitting access to their data - A user will need this to proceed\n# Please see http://cran.r-project.org/web/packages/twitteR/vignettes/twitteR.pdf for more info on this.\n\n#registerTwitterOAuth(credential)\n\n\n  shinyServer(function(input, output) {\n#     Authenticate <- function()\n#     {\n#       download.file(url='http://curl.haxx.se/ca/cacert.pem', destfile='cacert.pem')\n#       reqURL <- 'https://api.twitter.com/oauth/request_token'\n#       accessURL <- 'https://api.twitter.com/oauth/access_token'\n#       authURL <- 'https://api.twitter.com/oauth/authorize'\n#       consumerKey <- 'ST9Gsd0J9DxIjG6RnuwTsJ0a3' \n#       consumerSecret <- '5gBBjmYPPEsFDf9pyoU2ho1dIz3T0zFdZbvAtEmfxxjHp5ly6a' \n#       Cred <- OAuthFactory$new(consumerKey=consumerKey,\n#                                consumerSecret=consumerSecret,\n#                                requestURL=reqURL,\n#                                accessURL=accessURL,\n#                                authURL=authURL)\n#       Cred\n#       Cred$handshake(cainfo = system.file('CurlSSL', 'cacert.pem', package = 'RCurl'))\n#     }\n#     Authenticate()\n#     load_authentication<-function()\n#     {\n#       save(Cred, file='twitter authentication.Rdata')\n#       load('twitter authentication.Rdata') #Once you launch the code first time, you can start from this line in the future (libraries should be connected)\n#       setup_twitter_oauth(consumer_key='ST9Gsd0J9DxIjG6RnuwTsJ0a3', consumer_secret='5gBBjmYPPEsFDf9pyoU2ho1dIz3T0zFdZbvAtEmfxxjHp5ly6a', access_token='226090602-HYkdKxZILp7IXVZwcCY9UCboxMlXRn4X8khB71Yj', access_secret='SKrFY6rFP98IEK2imrNAe6h21rxKhOpin81tHYlJ2kzxv')\n#     }\n#     load_authentication()\n#     load(\"Cred\")\n#     registerTwitterOAuth(Cred)\n    clean.text <- function(some_txt)\n    {\n      some_txt = gsub(\"(RT|via)((?:\\\\b\\\\W*@\\\\w+)+)\", \"\", some_txt)\n      some_txt = gsub(\"@\\\\w+\", \"\", some_txt)\n      some_txt = gsub(\"[[:punct:]]\", \"\", some_txt)\n      some_txt = gsub(\"[[:digit:]]\", \"\", some_txt)\n      some_txt = gsub(\"http\\\\w+\", \"\", some_txt)\n      some_txt = gsub(\"[ \\t]{2,}\", \"\", some_txt)\n      some_txt = gsub(\"^\\\\s+|\\\\s+$\", \"\", some_txt)\n      some_txt = gsub(\"amp\", \"\", some_txt)\n      # define \"tolower error handling\" function\n      try.tolower = function(x)\n      {\n        y = NA\n        try_error = tryCatch(tolower(x), error=function(e) e)\n        if (!inherits(try_error, \"error\"))\n          y = tolower(x)\n        return(y)\n      }\n      \n      some_txt = sapply(some_txt, try.tolower)\n      some_txt = some_txt[some_txt != \"\"]\n      names(some_txt) = NULL\n      return(some_txt)\n    }\n    \n    getSentiment <- function (text, key){\n      \n      text <- URLencode(text);\n      \n      #save all the spaces, then get rid of the weird characters that break the API, then convert back the URL-encoded spaces.\n      text <- str_replace_all(text, \"%20\", \" \");\n      text <- str_replace_all(text, \"%\\\\d\\\\d\", \"\");\n      text <- str_replace_all(text, \" \", \"%20\");\n      \n      if (str_length(text) > 360){\n        text <- substr(text, 0, 359);\n      }\n      ##########################################\n      \n      data <- getURL(paste(\"http://api.datumbox.com/1.0/TwitterSentimentAnalysis.json?api_key=\", key, \"&text=\",text, sep=\"\"))\n      \n      js <- fromJSON(data, asText=TRUE);\n      \n      # get mood probability\n      sentiment = js$output$result\n      \n      ###################################\n      return(list(sentiment=sentiment))\n    }\n    \n    SentimentCloud <- function(keyword,n)\n    {\n      ## getting started\n      tweets = searchTwitter(keyword, n, lang=\"en\")\n      \n      # get text\n      tweet_txt = sapply(tweets, function(x) x$getText())\n      \n      # clean text\n      tweet_clean = clean.text(tweet_txt)\n      tweet_num = length(tweet_clean)\n      tweet_df = data.frame(text=tweet_clean, sentiment=rep(\"\", tweet_num),stringsAsFactors=FALSE)\n      \n      # apply function getSentiment\n      sentiment = rep(0, tweet_num)\n      db_key='ad3a9235644e84b0d2f9920f489dacd9'\n      for (i in 1:tweet_num)\n      {\n        tmp = getSentiment(tweet_clean[i], db_key)\n        \n        tweet_df$sentiment[i] = tmp$sentiment\n        \n        print(paste(i,\" of \", tweet_num))\n        \n      }\n      \n      # delete rows with no sentiment\n      tweet_df <- tweet_df[tweet_df$sentiment!=\"\",]\n      \n      #separate text by sentiment\n      sents = levels(factor(tweet_df$sentiment))\n      \n      labels <- lapply(sents, function(x) paste(x,format(round((length((tweet_df[tweet_df$sentiment ==x,])$text)/length(tweet_df$sentiment)*100),2),nsmall=2),\"%\"))\n      \n      nemo = length(sents)\n      emo.docs = rep(\"\", nemo)\n      for (i in 1:nemo)\n      {\n        tmp = tweet_df[tweet_df$sentiment == sents[i],]$text\n        \n        emo.docs[i] = paste(tmp,collapse=\" \")\n      }\n      # remove stopwords\n      emo.docs = removeWords(emo.docs, stopwords(\"german\"))\n      emo.docs = removeWords(emo.docs, stopwords(\"english\"))\n      corpus = Corpus(VectorSource(emo.docs))\n      tdm = TermDocumentMatrix(corpus)\n      tdm = as.matrix(tdm)\n      colnames(tdm) = labels\n      \n      #word cloud\n      #m = as.matrix(tdm) #we define tdm as matrix\n      \n      #word_freqs = sort(rowSums(m), decreasing=TRUE) #now we get the word orders in decreasing order\n      \n      #dm = data.frame(word=names(word_freqs), freq=word_freqs) #we create our data set\n      \n      #wordcloud(dm$word, dm$freq, random.order=FALSE, colors=brewer.pal(8, \"Dark2\")) #and we visualize our data\n      # comparison word cloud\n      comparison.cloud(tdm, colors = brewer.pal(nemo, \"Dark2\"),\n                       scale = c(3,.5), random.order = FALSE, title.size = 1.5)\n    }\n    \n  \n#   output$piechart<-renderPlot({\n#     if (input$goButton == 0)\n#       return()\n#   slices <- getSentimentCount(input$term,input$maxTweets)\n#   lbls <- c(\"Positive\", \"Negative\", \"Neutral\")\n#   pie3D(slices,labels=lbls,explode=0.1,\n#         main=\"Pie Chart of Sentiment Type\")\n#   })\n    \n    rawData <- reactive(function(){\n      tweets <- searchTwitter(input$term, n=input$maxTweets)\n      twListToDF(tweets)\n    })\n  \n  output$plot<-renderPlot({\n    if (input$goButton == 0)\n      return()\n    SentimentCloud(input$term,input$maxTweets)\n  })\n  \n  output$table <- renderTable(function () {\n    if (input$goButton == 0)\n      return()\n    head(rawData()[1],n=input$maxTweets)\n  })\n  \n#   output$distPlot <- renderPlot({\n#     if (input$goButton == 0)\n#       return()\n#     withProgress(session, min=1, max=15, {\n#       setProgress(message = 'Processeing... Please Wait...',\n#                   detail = 'This may take a while...')\n#       for (i in 1:input$maxTweets) {\n#         setProgress(value = i)\n#         Sys.sleep(0.5)\n#       }})})\n  \n#   output$distPlot <- renderPlot({\n#     input$goButton # Re-run when button is clicked\n#     \n#     withProgress(message = 'Creating plot', value = 0.1, {\n#       Sys.sleep(0.25)\n#       \n#       # Create 0-row data frame which will be used to store data\n#       dat <- data.frame(x = numeric(0), y = numeric(0))\n#       \n#       # withProgress calls can be nested, in which case the nested text appears\n#       # below, and a second bar is shown.\n#       withProgress(message = 'Generating data', detail = \"part 0\", value = 0, {\n#         for (i in 1:10) {\n#           # Each time through the loop, add another row of data. This a stand-in\n#           # for a long-running computation.\n#           dat <- rbind(dat, data.frame(x = rnorm(1), y = rnorm(1)))\n#           \n#           # Increment the progress bar, and update the detail text.\n#           incProgress(0.1, detail = paste(\"part\", i))\n#           \n#           # Pause for 0.1 seconds to simulate a long computation.\n#           Sys.sleep(0.1)\n#         }\n#       })\n#     })\n#   })\n  \n})\n\n\n\n",
    "created" : 1461437392473.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1597656738",
    "id" : "18CBE1A3",
    "lastKnownWriteTime" : 1461440101,
    "last_content_update" : 1461440101866,
    "path" : "~/Twitter_Sentiment/server.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}